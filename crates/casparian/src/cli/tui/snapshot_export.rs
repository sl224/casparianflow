//! Snapshot exporter for LLM TUI review bundles.

use std::fs;
use std::path::PathBuf;

use anyhow::{Context, Result};
use clap::Args;
use serde::Serialize;

use super::app::TuiMode;
use super::snapshot::{
    buffer_to_bg_mask, buffer_to_plain_text, layout_tree, normalize_for_snapshot,
    render_app_to_buffer,
};
use super::snapshot_states::{snapshot_cases, DEFAULT_SNAPSHOT_SIZES};

#[derive(Debug, Args)]
pub struct TuiSnapshotArgs {
    /// Output directory for snapshot artifacts
    #[arg(long, default_value = ".test_output/tui_snapshots")]
    pub out: PathBuf,

    /// Comma-separated list of sizes (e.g., 80x24,120x40)
    #[arg(long, default_value = "80x24,100x30,120x40,160x50")]
    pub sizes: String,
}

#[derive(Debug, Serialize)]
struct SnapshotCaseMeta {
    name: String,
    mode: String,
    notes: String,
    focus_hint: String,
    coverage: String,
    sizes: Vec<String>,
}

pub fn run(args: TuiSnapshotArgs) -> Result<()> {
    let sizes = parse_sizes(&args.sizes)?;
    fs::create_dir_all(&args.out)
        .with_context(|| format!("create snapshot output dir {}", args.out.display()))?;

    let size_labels: Vec<String> = sizes.iter().map(|(w, h)| format!("{}x{}", w, h)).collect();

    let mut bundle = String::new();
    bundle.push_str("# TUI Snapshot Bundle\n\n");
    bundle.push_str("Generated by `casparian tui-snapshots`.\n\n");
    bundle.push_str(&format!("Sizes: {}\n\n", size_labels.join(", ")));
    bundle.push_str("## Table of Contents\n");
    for case in snapshot_cases() {
        bundle.push_str(&format!("- [{}](#{})\n", case.name, case.name));
    }
    bundle.push_str("\n");

    for case in snapshot_cases() {
        let case_dir = args.out.join(case.name);
        fs::create_dir_all(&case_dir)
            .with_context(|| format!("create case dir {}", case_dir.display()))?;

        let app_for_meta = (case.build)();
        let meta = SnapshotCaseMeta {
            name: case.name.to_string(),
            mode: mode_label(app_for_meta.mode).to_string(),
            notes: case.notes.to_string(),
            focus_hint: case.focus_hint.to_string(),
            coverage: case.coverage.as_str().to_string(),
            sizes: size_labels.clone(),
        };
        let meta_path = case_dir.join(format!("{}.meta.json", case.name));
        fs::write(&meta_path, serde_json::to_string_pretty(&meta)?)
            .with_context(|| format!("write {}", meta_path.display()))?;

        bundle.push_str(&format!("## {}\n\n", case.name));
        if !case.notes.is_empty() {
            bundle.push_str(&format!("Notes: {}\n\n", case.notes));
        }
        if !case.focus_hint.is_empty() {
            bundle.push_str(&format!("Focus: {}\n\n", case.focus_hint));
        }
        bundle.push_str(&format!("Coverage: {}\n\n", case.coverage.as_str()));
        bundle.push_str(&format!("Mode: {}\n\n", mode_label(app_for_meta.mode)));

        for (width, height) in &sizes {
            let app = (case.build)();
            let buffer = render_app_to_buffer(&app, *width, *height)
                .with_context(|| format!("render {} at {}x{}", case.name, width, height))?;

            let plain = normalize_for_snapshot(&buffer_to_plain_text(&buffer));
            let mask = normalize_for_snapshot(&buffer_to_bg_mask(&buffer));
            let layout = layout_tree(&app, *width, *height);

            let base = format!("{}__{}x{}", case.name, width, height);
            let text_path = case_dir.join(format!("{}.txt", base));
            let mask_path = case_dir.join(format!("{}.mask.txt", base));
            let layout_path = case_dir.join(format!("{}.layout.json", base));

            fs::write(&text_path, &plain)
                .with_context(|| format!("write {}", text_path.display()))?;
            fs::write(&mask_path, &mask)
                .with_context(|| format!("write {}", mask_path.display()))?;
            fs::write(&layout_path, serde_json::to_string_pretty(&layout)?)
                .with_context(|| format!("write {}", layout_path.display()))?;

            bundle.push_str(&format!("### {}x{}\n\n", width, height));
            bundle.push_str("Plain:\n\n```text\n");
            bundle.push_str(&plain);
            bundle.push_str("\n```\n\nMask:\n\n```text\n");
            bundle.push_str(&mask);
            bundle.push_str("\n```\n\n");
        }
    }

    let bundle_path = args.out.join("tui_snapshots.md");
    fs::write(&bundle_path, bundle).with_context(|| format!("write {}", bundle_path.display()))?;

    Ok(())
}

fn parse_sizes(input: &str) -> Result<Vec<(u16, u16)>> {
    if input.trim().is_empty() {
        return Ok(DEFAULT_SNAPSHOT_SIZES.to_vec());
    }

    let mut sizes = Vec::new();
    for part in input.split(',') {
        let trimmed = part.trim();
        let (w, h) = trimmed
            .split_once('x')
            .with_context(|| format!("invalid size '{}', expected WxH", trimmed))?;
        let width: u16 = w
            .parse()
            .with_context(|| format!("invalid width '{}', expected u16", w))?;
        let height: u16 = h
            .parse()
            .with_context(|| format!("invalid height '{}', expected u16", h))?;
        if width == 0 || height == 0 {
            anyhow::bail!("invalid size '{}': width/height must be > 0", trimmed);
        }
        sizes.push((width, height));
    }

    if sizes.is_empty() {
        Ok(DEFAULT_SNAPSHOT_SIZES.to_vec())
    } else {
        Ok(sizes)
    }
}

fn mode_label(mode: TuiMode) -> &'static str {
    match mode {
        TuiMode::Home => "Home",
        TuiMode::Discover => "Discover",
        TuiMode::Jobs => "Jobs",
        TuiMode::Sources => "Sources",
        TuiMode::Approvals => "Approvals",
        TuiMode::ParserBench => "Parser Bench",
        TuiMode::Query => "Query",
        TuiMode::Settings => "Settings",
        TuiMode::Sessions => "Sessions",
        TuiMode::Triage => "Triage",
        TuiMode::Catalog => "Catalog",
    }
}
