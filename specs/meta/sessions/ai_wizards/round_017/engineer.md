# Engineer Resolution: GAP-INT-005

## Python Extractor Validation Specification

**Gap:** When the Pathfinder Wizard generates Python extractors (fallback from YAML), there's no specification for:
1. How the generated Python is validated before presenting to user
2. Syntax checking
3. Security validation (no dangerous imports, no file system access)
4. Runtime behavior testing with sample paths
5. Error handling when validation fails

**Confidence:** HIGH

---

## 1. Validation Pipeline Overview

Python extractors generated by the Pathfinder Wizard go through a **four-stage validation pipeline** before being presented to the user:

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Stage 1   │────►│   Stage 2   │────►│   Stage 3   │────►│   Stage 4   │
│   Syntax    │     │  Security   │     │  Signature  │     │  Sandbox    │
│  Validation │     │    Scan     │     │ Validation  │     │   Test      │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
       │                   │                   │                   │
       ▼                   ▼                   ▼                   ▼
   Parse AST          Import check       Function sig       Execute with
   Detect errors      Block dangerous    Return type        sample paths
```

**Pipeline Properties:**
- **Fail-fast**: Pipeline stops at first stage failure
- **Retry-aware**: Each stage failure can trigger LLM retry with specific error context
- **User-transparent**: Validation progress shown in UI during GENERATING state

---

## 2. Stage 1: Syntax Validation

### 2.1 AST Parsing

All generated Python code is parsed using Python's `ast` module to detect syntax errors before any execution:

```python
import ast
from dataclasses import dataclass
from typing import Optional, List

@dataclass
class SyntaxValidationResult:
    valid: bool
    error_message: Optional[str] = None
    error_line: Optional[int] = None
    error_column: Optional[int] = None
    suggestions: List[str] = None

def validate_syntax(code: str) -> SyntaxValidationResult:
    """
    Parse Python code and return validation result.

    Returns:
        SyntaxValidationResult with error details if invalid
    """
    try:
        ast.parse(code)
        return SyntaxValidationResult(valid=True)
    except SyntaxError as e:
        suggestions = generate_syntax_suggestions(e, code)
        return SyntaxValidationResult(
            valid=False,
            error_message=e.msg,
            error_line=e.lineno,
            error_column=e.offset,
            suggestions=suggestions,
        )
```

### 2.2 Common Syntax Error Suggestions

The validation system provides actionable suggestions for common LLM-generated syntax errors:

| Error Pattern | Detection | Suggestion |
|---------------|-----------|------------|
| Unclosed string | `EOL while scanning string literal` | "Add closing quote on line {N}" |
| Unclosed parenthesis | `unexpected EOF while parsing` | "Missing closing parenthesis" |
| Invalid indentation | `unexpected indent` / `IndentationError` | "Check indentation on line {N}" |
| Missing colon | `expected ':'` | "Add colon after function/if/for definition" |
| Invalid f-string | `f-string expression part cannot include...` | "Escape braces or simplify f-string" |
| Markdown fences | `invalid syntax` at line 1 with "```" | "Strip markdown code fences" |

```python
def generate_syntax_suggestions(error: SyntaxError, code: str) -> List[str]:
    """Generate human-readable suggestions for syntax errors."""
    suggestions = []

    # Markdown fence detection (common LLM artifact)
    if code.strip().startswith("```"):
        suggestions.append("Remove markdown code fences (```python ... ```)")
        return suggestions

    # Pattern-based suggestions
    if "EOL while scanning" in str(error.msg):
        suggestions.append(f"Add closing quote on line {error.lineno}")

    if "unexpected EOF" in str(error.msg):
        # Count brackets
        opens = code.count('(') + code.count('[') + code.count('{')
        closes = code.count(')') + code.count(']') + code.count('}')
        if opens > closes:
            suggestions.append("Missing closing bracket/parenthesis")

    if "IndentationError" in type(error).__name__ or "indent" in str(error.msg).lower():
        suggestions.append(f"Check indentation on line {error.lineno} (use 4 spaces)")

    if "expected ':'" in str(error.msg):
        suggestions.append("Add colon after function, class, if, for, or while")

    return suggestions or ["Check syntax near the indicated line"]
```

### 2.3 Pre-Parsing Cleanup

Before AST parsing, common LLM output artifacts are cleaned:

```python
def preprocess_llm_output(raw_output: str) -> str:
    """
    Clean LLM output before validation.

    Handles:
    - Markdown code fences (```python ... ```)
    - Leading/trailing whitespace
    - Windows line endings
    """
    code = raw_output.strip()

    # Strip markdown fences
    if code.startswith("```python"):
        code = code[len("```python"):].lstrip()
    elif code.startswith("```"):
        code = code[3:].lstrip()

    if code.endswith("```"):
        code = code[:-3].rstrip()

    # Normalize line endings
    code = code.replace('\r\n', '\n')

    return code
```

---

## 3. Stage 2: Security Scan

### 3.1 Import Whitelist

Python extractors operate in a restricted environment. Only a curated set of imports is allowed:

**Allowed Imports (Whitelist):**

| Category | Modules | Rationale |
|----------|---------|-----------|
| **Path operations** | `pathlib`, `os.path` | Core extractor functionality |
| **String/Pattern** | `re`, `string`, `fnmatch` | Pattern matching, string manipulation |
| **Date/Time** | `datetime`, `time` | Date parsing from paths |
| **Type hints** | `typing`, `collections.abc` | Type annotations |
| **Data structures** | `collections`, `dataclasses`, `enum` | Helper types |
| **JSON parsing** | `json` | Parsing embedded JSON in paths |
| **Math** | `math` | Numeric computations |
| **UUID** | `uuid` | UUID parsing/generation |
| **Base64** | `base64` | Decoding base64 segments |
| **URL parsing** | `urllib.parse` | Parsing URL-encoded segments |
| **Hashlib** | `hashlib` | Computing hashes (read-only) |

**Blocked Imports (Explicit Deny):**

| Category | Modules | Reason |
|----------|---------|--------|
| **File I/O** | `open`, `io`, `shutil`, `tempfile`, `fileinput` | No file access allowed |
| **Network** | `socket`, `urllib.request`, `http`, `ftplib`, `smtplib` | No network access |
| **Subprocess** | `subprocess`, `os.system`, `os.popen`, `commands` | No shell execution |
| **Code execution** | `exec`, `eval`, `compile`, `__import__` | No dynamic code |
| **System access** | `sys`, `os` (except `os.path`), `platform`, `ctypes` | No system access |
| **Pickle** | `pickle`, `shelve`, `marshal` | Deserialization attacks |
| **Multiprocessing** | `multiprocessing`, `threading`, `concurrent` | No parallelism |

### 3.2 AST-Based Security Scanner

```python
import ast
from dataclasses import dataclass
from typing import Set, List, Optional

# Whitelist of allowed modules and specific imports
ALLOWED_IMPORTS = {
    # Full modules
    "pathlib",
    "re",
    "string",
    "fnmatch",
    "datetime",
    "time",
    "typing",
    "collections",
    "dataclasses",
    "enum",
    "json",
    "math",
    "uuid",
    "base64",
    "hashlib",
    "urllib.parse",
    # Specific imports from os
    "os.path",
}

# Explicit blocklist (for error messages)
BLOCKED_IMPORTS = {
    "os": "Full 'os' module blocked (use 'os.path' for path operations)",
    "sys": "System access not allowed in extractors",
    "subprocess": "Shell execution not allowed",
    "socket": "Network access not allowed",
    "urllib.request": "Network requests not allowed",
    "http": "HTTP access not allowed",
    "pickle": "Deserialization not allowed",
    "io": "File I/O not allowed (extractor receives path as string)",
    "open": "File I/O not allowed",
    "shutil": "File operations not allowed",
    "tempfile": "Temp file creation not allowed",
}

# Blocked builtins
BLOCKED_BUILTINS = {
    "exec": "Dynamic code execution not allowed",
    "eval": "Dynamic code execution not allowed",
    "compile": "Dynamic code execution not allowed",
    "__import__": "Dynamic imports not allowed",
    "open": "File I/O not allowed",
    "input": "Interactive input not allowed",
    "breakpoint": "Debugging not allowed",
}

@dataclass
class SecurityViolation:
    violation_type: str  # "forbidden_import", "forbidden_builtin", "forbidden_attribute"
    item: str            # The offending import/call
    line: int
    column: int
    reason: str          # Human-readable explanation

@dataclass
class SecurityScanResult:
    safe: bool
    violations: List[SecurityViolation]

class SecurityScanner(ast.NodeVisitor):
    """AST visitor that detects security violations in extractor code."""

    def __init__(self):
        self.violations: List[SecurityViolation] = []

    def visit_Import(self, node: ast.Import):
        """Check 'import X' statements."""
        for alias in node.names:
            module = alias.name
            if not self._is_allowed_import(module):
                reason = BLOCKED_IMPORTS.get(module, f"Module '{module}' not in whitelist")
                self.violations.append(SecurityViolation(
                    violation_type="forbidden_import",
                    item=module,
                    line=node.lineno,
                    column=node.col_offset,
                    reason=reason,
                ))
        self.generic_visit(node)

    def visit_ImportFrom(self, node: ast.ImportFrom):
        """Check 'from X import Y' statements."""
        module = node.module or ""

        # Check base module
        if not self._is_allowed_import(module):
            reason = BLOCKED_IMPORTS.get(module, f"Module '{module}' not in whitelist")
            self.violations.append(SecurityViolation(
                violation_type="forbidden_import",
                item=module,
                line=node.lineno,
                column=node.col_offset,
                reason=reason,
            ))
        self.generic_visit(node)

    def visit_Call(self, node: ast.Call):
        """Check function calls for blocked builtins."""
        # Check direct calls like exec(), eval()
        if isinstance(node.func, ast.Name):
            name = node.func.id
            if name in BLOCKED_BUILTINS:
                self.violations.append(SecurityViolation(
                    violation_type="forbidden_builtin",
                    item=name,
                    line=node.lineno,
                    column=node.col_offset,
                    reason=BLOCKED_BUILTINS[name],
                ))
        self.generic_visit(node)

    def visit_Attribute(self, node: ast.Attribute):
        """Check for dangerous attribute access patterns."""
        # Detect os.system, os.popen, etc.
        if isinstance(node.value, ast.Name):
            if node.value.id == "os" and node.attr not in ("path", "sep", "altsep", "extsep", "pathsep"):
                self.violations.append(SecurityViolation(
                    violation_type="forbidden_attribute",
                    item=f"os.{node.attr}",
                    line=node.lineno,
                    column=node.col_offset,
                    reason=f"os.{node.attr} not allowed (only os.path permitted)",
                ))
        self.generic_visit(node)

    def _is_allowed_import(self, module: str) -> bool:
        """Check if a module is in the whitelist."""
        # Direct match
        if module in ALLOWED_IMPORTS:
            return True

        # Check if it's a submodule of an allowed module
        for allowed in ALLOWED_IMPORTS:
            if module.startswith(allowed + "."):
                return True

        # Special case: os.path is allowed, but not os
        if module == "os.path":
            return True

        return False

def scan_security(code: str) -> SecurityScanResult:
    """
    Scan Python code for security violations.

    Args:
        code: Python source code (must be valid syntax)

    Returns:
        SecurityScanResult with list of violations
    """
    tree = ast.parse(code)
    scanner = SecurityScanner()
    scanner.visit(tree)

    return SecurityScanResult(
        safe=len(scanner.violations) == 0,
        violations=scanner.violations,
    )
```

### 3.3 Security Scan Error Messages

When security violations are detected, provide clear feedback:

```python
def format_security_violations(result: SecurityScanResult) -> str:
    """Format security violations for LLM retry prompt."""
    if result.safe:
        return ""

    lines = ["Security violations detected in generated extractor:"]
    for v in result.violations:
        lines.append(f"  Line {v.line}: {v.violation_type}")
        lines.append(f"    Item: {v.item}")
        lines.append(f"    Reason: {v.reason}")

    lines.append("")
    lines.append("Allowed imports: pathlib, re, datetime, typing, collections, json, math, uuid, base64, os.path")
    lines.append("The extractor function receives a path string and must return a dict. No file I/O needed.")

    return "\n".join(lines)
```

---

## 4. Stage 3: Signature Validation

### 4.1 Required Function Signature

Python extractors MUST have an `extract` function with the following signature:

```python
def extract(path: str) -> dict:
    """
    Extract metadata from a file path.

    Args:
        path: Absolute file path as string

    Returns:
        Dictionary of extracted metadata (field_name -> value)
    """
    ...
```

### 4.2 Signature Validation Logic

```python
import ast
from dataclasses import dataclass
from typing import Optional, List

@dataclass
class SignatureValidationResult:
    valid: bool
    errors: List[str]
    warnings: List[str]

def validate_signature(code: str) -> SignatureValidationResult:
    """
    Validate that code contains a valid extract() function.

    Checks:
    1. Function named 'extract' exists
    2. Has exactly one parameter (path)
    3. Returns dict (if annotated)
    """
    tree = ast.parse(code)
    errors = []
    warnings = []

    # Find the extract function
    extract_func = None
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == "extract":
            extract_func = node
            break

    if extract_func is None:
        errors.append("Missing required function: def extract(path: str) -> dict")
        return SignatureValidationResult(valid=False, errors=errors, warnings=warnings)

    # Check parameter count
    args = extract_func.args
    total_params = len(args.args) + len(args.posonlyargs)

    if total_params == 0:
        errors.append("extract() must have at least one parameter (path)")
    elif total_params > 1:
        # Allow extra params if they have defaults
        required_params = total_params - len(args.defaults)
        if required_params > 1:
            errors.append(f"extract() should have 1 required parameter, found {required_params}")

    # Check parameter name (warning, not error)
    if args.args and args.args[0].arg != "path":
        warnings.append(f"First parameter is '{args.args[0].arg}', expected 'path'")

    # Check return annotation if present
    if extract_func.returns:
        if isinstance(extract_func.returns, ast.Name):
            if extract_func.returns.id != "dict":
                warnings.append(f"Return type is '{extract_func.returns.id}', expected 'dict'")
        elif isinstance(extract_func.returns, ast.Subscript):
            # Allow Dict[str, Any] etc.
            if hasattr(extract_func.returns.value, 'id'):
                if extract_func.returns.value.id not in ("dict", "Dict"):
                    warnings.append("Return type should be dict")

    # Check for return statements
    has_return = False
    for node in ast.walk(extract_func):
        if isinstance(node, ast.Return) and node.value is not None:
            has_return = True
            break

    if not has_return:
        errors.append("extract() must return a dictionary")

    return SignatureValidationResult(
        valid=len(errors) == 0,
        errors=errors,
        warnings=warnings,
    )
```

---

## 5. Stage 4: Sandbox Execution Test

### 5.1 Sandbox Environment

The generated extractor is executed in a restricted environment against sample paths to verify:
1. No runtime errors
2. Returns a dictionary
3. Extracted values are reasonable

**Sandbox Properties:**

| Property | Value | Rationale |
|----------|-------|-----------|
| Timeout | 5 seconds per path | Prevent infinite loops |
| Memory limit | 100 MB | Prevent memory exhaustion |
| No network | Blocked at syscall level | Security |
| No file I/O | Module restrictions | Security |
| Read-only filesystem | N/A (no FS access) | Security |

### 5.2 Sandbox Implementation

```python
import multiprocessing
import traceback
from dataclasses import dataclass
from typing import Dict, Any, List, Optional

@dataclass
class SandboxTestResult:
    success: bool
    path: str
    result: Optional[Dict[str, Any]]
    error: Optional[str]
    error_type: Optional[str]
    execution_time_ms: float

@dataclass
class SandboxTestSuite:
    passed: int
    failed: int
    results: List[SandboxTestResult]

    @property
    def all_passed(self) -> bool:
        return self.failed == 0

def _execute_in_sandbox(code: str, path: str, timeout: float = 5.0) -> SandboxTestResult:
    """
    Execute extractor code in isolated subprocess with timeout.

    Uses multiprocessing to isolate execution and enforce timeout.
    """
    import time
    start = time.perf_counter()

    def run_extractor(code: str, path: str, result_queue):
        """Worker function executed in subprocess."""
        try:
            # Create restricted globals
            restricted_globals = {
                "__builtins__": {
                    # Only safe builtins
                    "str": str,
                    "int": int,
                    "float": float,
                    "bool": bool,
                    "list": list,
                    "dict": dict,
                    "tuple": tuple,
                    "set": set,
                    "len": len,
                    "range": range,
                    "enumerate": enumerate,
                    "zip": zip,
                    "map": map,
                    "filter": filter,
                    "sorted": sorted,
                    "reversed": reversed,
                    "min": min,
                    "max": max,
                    "sum": sum,
                    "any": any,
                    "all": all,
                    "isinstance": isinstance,
                    "type": type,
                    "hasattr": hasattr,
                    "getattr": getattr,
                    "setattr": setattr,
                    "None": None,
                    "True": True,
                    "False": False,
                    "Exception": Exception,
                    "ValueError": ValueError,
                    "TypeError": TypeError,
                    "KeyError": KeyError,
                    "IndexError": IndexError,
                    "AttributeError": AttributeError,
                },
            }

            # Execute code to define the extract function
            exec(code, restricted_globals)

            # Get the extract function
            extract_func = restricted_globals.get("extract")
            if extract_func is None:
                result_queue.put(("error", "extract function not defined", "DefinitionError"))
                return

            # Call extract with the path
            result = extract_func(path)

            # Validate return type
            if not isinstance(result, dict):
                result_queue.put(("error", f"extract() returned {type(result).__name__}, expected dict", "TypeError"))
                return

            result_queue.put(("success", result, None))

        except Exception as e:
            tb = traceback.format_exc()
            result_queue.put(("error", str(e), type(e).__name__))

    # Run in subprocess with timeout
    result_queue = multiprocessing.Queue()
    process = multiprocessing.Process(
        target=run_extractor,
        args=(code, path, result_queue)
    )

    process.start()
    process.join(timeout=timeout)

    elapsed = (time.perf_counter() - start) * 1000  # ms

    if process.is_alive():
        process.terminate()
        process.join()
        return SandboxTestResult(
            success=False,
            path=path,
            result=None,
            error=f"Execution timed out after {timeout}s",
            error_type="TimeoutError",
            execution_time_ms=elapsed,
        )

    if result_queue.empty():
        return SandboxTestResult(
            success=False,
            path=path,
            result=None,
            error="No result from subprocess (possible crash)",
            error_type="CrashError",
            execution_time_ms=elapsed,
        )

    status, data, error_type = result_queue.get()

    if status == "success":
        return SandboxTestResult(
            success=True,
            path=path,
            result=data,
            error=None,
            error_type=None,
            execution_time_ms=elapsed,
        )
    else:
        return SandboxTestResult(
            success=False,
            path=path,
            result=None,
            error=data,
            error_type=error_type,
            execution_time_ms=elapsed,
        )


def run_sandbox_tests(code: str, sample_paths: List[str], timeout_per_path: float = 5.0) -> SandboxTestSuite:
    """
    Run extractor against multiple sample paths in sandbox.

    Args:
        code: Python extractor code
        sample_paths: List of file paths to test
        timeout_per_path: Timeout per extraction in seconds

    Returns:
        SandboxTestSuite with results for each path
    """
    results = []

    for path in sample_paths:
        result = _execute_in_sandbox(code, path, timeout_per_path)
        results.append(result)

    passed = sum(1 for r in results if r.success)
    failed = len(results) - passed

    return SandboxTestSuite(
        passed=passed,
        failed=failed,
        results=results,
    )
```

### 5.3 Result Validation

Beyond successful execution, validate that extracted values are sensible:

```python
@dataclass
class ExtractionQualityResult:
    acceptable: bool
    warnings: List[str]

def validate_extraction_quality(results: SandboxTestSuite) -> ExtractionQualityResult:
    """
    Validate that extraction results are reasonable.

    Checks:
    1. At least some paths produce non-empty results
    2. Field names are valid identifiers
    3. Values are JSON-serializable
    """
    warnings = []

    # Check for all-empty results
    successful_results = [r for r in results.results if r.success]
    if not successful_results:
        return ExtractionQualityResult(
            acceptable=False,
            warnings=["All extractions failed"],
        )

    non_empty = [r for r in successful_results if r.result]
    if not non_empty:
        warnings.append("All successful extractions returned empty dict")

    # Check field name validity
    for r in successful_results:
        if r.result:
            for key in r.result.keys():
                if not key.isidentifier():
                    warnings.append(f"Field name '{key}' is not a valid Python identifier")

    # Check value serializability
    import json
    for r in successful_results:
        if r.result:
            try:
                json.dumps(r.result)
            except (TypeError, ValueError) as e:
                warnings.append(f"Result for {r.path} is not JSON-serializable: {e}")

    return ExtractionQualityResult(
        acceptable=len(non_empty) > 0,
        warnings=warnings,
    )
```

---

## 6. Retry on Validation Failure

### 6.1 Stage-Specific Retry Context

Each validation stage provides specific context for LLM retry:

```python
def build_retry_prompt(stage: str, original_prompt: str, error_context: str) -> str:
    """
    Build retry prompt with stage-specific error context.
    """
    stage_headers = {
        "syntax": "The generated code has syntax errors:",
        "security": "The generated code contains forbidden operations:",
        "signature": "The extract() function has signature problems:",
        "sandbox": "The extractor failed during test execution:",
    }

    header = stage_headers.get(stage, "The generated code has errors:")

    return f"""{original_prompt}

---
PREVIOUS ATTEMPT FAILED

{header}
{error_context}

Please regenerate the extractor function, fixing the issues above.
Remember:
- The function must be: def extract(path: str) -> dict
- Only use allowed imports: pathlib, re, datetime, typing, collections, json, math, uuid, base64, os.path
- No file I/O - you receive the path as a string, not file contents
- Return a dict with extracted metadata fields
"""
```

### 6.2 Retry Budget

The validation pipeline consumes retries from the wizard's retry budget (3 retries total, shared across all stages):

| Stage | Retry Worthiness | Rationale |
|-------|------------------|-----------|
| Syntax | HIGH | LLMs often fix syntax with specific error |
| Security | HIGH | Can regenerate without blocked imports |
| Signature | HIGH | Simple structural fix |
| Sandbox | MEDIUM | May indicate fundamental logic error |

```python
@dataclass
class ValidationPipelineResult:
    stage_reached: str  # "syntax", "security", "signature", "sandbox", "complete"
    valid: bool
    retry_context: Optional[str]
    test_results: Optional[SandboxTestSuite]
    quality_warnings: List[str]

def run_validation_pipeline(code: str, sample_paths: List[str]) -> ValidationPipelineResult:
    """
    Run full validation pipeline on generated extractor.
    """
    # Stage 1: Syntax
    code = preprocess_llm_output(code)
    syntax_result = validate_syntax(code)
    if not syntax_result.valid:
        return ValidationPipelineResult(
            stage_reached="syntax",
            valid=False,
            retry_context=format_syntax_error(syntax_result),
            test_results=None,
            quality_warnings=[],
        )

    # Stage 2: Security
    security_result = scan_security(code)
    if not security_result.safe:
        return ValidationPipelineResult(
            stage_reached="security",
            valid=False,
            retry_context=format_security_violations(security_result),
            test_results=None,
            quality_warnings=[],
        )

    # Stage 3: Signature
    sig_result = validate_signature(code)
    if not sig_result.valid:
        return ValidationPipelineResult(
            stage_reached="signature",
            valid=False,
            retry_context=format_signature_errors(sig_result),
            test_results=None,
            quality_warnings=[],
        )

    # Stage 4: Sandbox Test
    test_results = run_sandbox_tests(code, sample_paths)
    if not test_results.all_passed:
        return ValidationPipelineResult(
            stage_reached="sandbox",
            valid=False,
            retry_context=format_sandbox_failures(test_results),
            test_results=test_results,
            quality_warnings=[],
        )

    # Stage 5: Quality Check (warnings only, doesn't fail)
    quality_result = validate_extraction_quality(test_results)

    return ValidationPipelineResult(
        stage_reached="complete",
        valid=True,
        retry_context=None,
        test_results=test_results,
        quality_warnings=quality_result.warnings,
    )
```

### 6.3 Maximum Retry Behavior

After 3 failed retries, the wizard transitions to ANALYSIS_ERROR state:

```
┌─────────────────────────────────────────────────────────────────┐
│  PATHFINDER WIZARD - VALIDATION FAILED                          │
│                                                                  │
│  AI could not generate a valid extractor after 3 attempts.      │
│                                                                  │
│  Last error (sandbox test):                                      │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  ValueError: invalid literal for int() with base 10: 'Q1'  │ │
│  │  at line 12, in extract()                                  │ │
│  │    quarter = int(part)  # 'Q1' is not an integer          │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Options:                                                        │
│  [h] Add hint - Provide more context for AI                     │
│  [e] Edit manually - Open code in $EDITOR                       │
│  [r] Retry fresh - Start over with full retry budget            │
│  [Esc] Cancel - Abandon wizard                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. Fallback to Simpler Extraction

### 7.1 Fallback Triggers

When Python generation fails repeatedly, offer YAML fallback:

| Scenario | Fallback Option |
|----------|-----------------|
| 3 Python failures, original reason was "computed fields" | Offer YAML with simpler (non-computed) fields |
| Security violations on every retry | Offer YAML (inherently safe) |
| Sandbox timeouts | Offer YAML (no runtime execution risk) |

### 7.2 Degraded YAML Generation

```
┌─────────────────────────────────────────────────────────────────┐
│  PATHFINDER WIZARD - FALLBACK OPTION                            │
│                                                                  │
│  Python extractor generation failed. Would you like to try a    │
│  simpler YAML rule instead?                                      │
│                                                                  │
│  Original request:                                               │
│    "Quarter folder should compute start/end month"              │
│                                                                  │
│  YAML cannot compute derived fields, but can extract:            │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  extract:                                                   │ │
│  │    client_id:                                               │ │
│  │      from: segment(-4)                                      │ │
│  │      pattern: "CLIENT-(.*)"                                 │ │
│  │    year:                                                    │ │
│  │      from: segment(-3)                                      │ │
│  │      type: integer                                          │ │
│  │    quarter:                                                 │ │
│  │      from: segment(-2)                                      │ │
│  │      pattern: "Q(\\d)"                                      │ │
│  │      # NOTE: start_month/end_month computation not possible │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  [y] Use YAML (simpler)   [e] Edit Python manually   [Esc] Cancel│
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. User Feedback During Validation

### 8.1 Validation Progress Display

During GENERATING state, show validation progress:

```
┌─ PATHFINDER WIZARD ─────────────────────────────────────────────┐
│                                                                  │
│  Generating Python extractor...                                  │
│                                                                  │
│  Validation progress:                                            │
│  ├─ Syntax check:    ✓                                          │
│  ├─ Security scan:   ✓                                          │
│  ├─ Signature check: ✓                                          │
│  └─ Sandbox tests:   ▶ Running (3/5 paths)...                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 Validation Status in Result View

When extractor passes validation, show confirmation:

```
┌─ PATHFINDER WIZARD ─────────────────────────────────────────────┐
│                                                                  │
│  Sample Path: /data/CLIENT-ABC/2024/Q1/report.csv               │
│                                                                  │
│  Output: Python Extractor                                        │
│  Validation: ✓ Passed (5/5 paths, avg 2.3ms)                    │
│                                                                  │
│  ┌─ Generated Code ─────────────────────────────────────────────┐│
│  │  from pathlib import Path                                    ││
│  │                                                              ││
│  │  def extract(path: str) -> dict:                             ││
│  │      parts = Path(path).parts                                ││
│  │      ...                                                     ││
│  └──────────────────────────────────────────────────────────────┘│
│                                                                  │
│  ┌─ Preview (sample extractions) ───────────────────────────────┐│
│  │  ✓ report.csv → {client_id: "ABC", year: 2024, quarter: 1}  ││
│  │  ✓ data.csv   → {client_id: "XYZ", year: 2024, quarter: 2}  ││
│  └──────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Extractor name: client_reports_______                           │
│                                                                  │
│  [Enter] Approve   [e] Edit   [r] Regenerate   [h] Hint   [Esc] │
└─────────────────────────────────────────────────────────────────┘
```

### 8.3 Validation Warnings (Non-Blocking)

Quality warnings don't block approval but are displayed:

```
│  Validation: ✓ Passed with warnings                              │
│  ⚠ 1 path returned empty dict (may be expected)                 │
│  ⚠ Field 'Q1' contains non-identifier character                 │
```

---

## 9. Implementation Checklist

### Phase 1: Core Validation (1 day)
- [ ] Implement `validate_syntax()` with AST parsing
- [ ] Implement `preprocess_llm_output()` for markdown cleanup
- [ ] Implement `generate_syntax_suggestions()`
- [ ] Unit tests for syntax validation

### Phase 2: Security Scanner (1 day)
- [ ] Implement `SecurityScanner` AST visitor
- [ ] Define import whitelist/blocklist
- [ ] Implement `scan_security()`
- [ ] Unit tests for all blocked patterns

### Phase 3: Signature Validation (0.5 day)
- [ ] Implement `validate_signature()`
- [ ] Add warning vs error distinction
- [ ] Unit tests for signature validation

### Phase 4: Sandbox Execution (1.5 days)
- [ ] Implement subprocess-based sandbox
- [ ] Implement timeout handling
- [ ] Implement restricted builtins dict
- [ ] Implement `run_sandbox_tests()`
- [ ] Implement `validate_extraction_quality()`
- [ ] Unit tests with mock extractors

### Phase 5: Pipeline Integration (1 day)
- [ ] Implement `run_validation_pipeline()`
- [ ] Implement retry prompt generation
- [ ] Integrate with wizard state machine
- [ ] Add progress display in TUI
- [ ] Add validation status to result view

### Phase 6: Fallback Support (0.5 day)
- [ ] Implement YAML fallback offer dialog
- [ ] Wire fallback trigger conditions
- [ ] Update state machine for fallback flow

---

## 10. Spec Updates Required

Add to `specs/ai_wizards.md` after Section 3.1.1:

```markdown
#### 3.1.2 Python Extractor Validation

When the Pathfinder Wizard generates Python extractors (fallback from YAML), the code passes through a four-stage validation pipeline:

**Validation Pipeline:**

```
LLM Output → Syntax → Security → Signature → Sandbox → User Review
```

| Stage | Purpose | Failure Action |
|-------|---------|----------------|
| **Syntax** | AST parsing, detect syntax errors | Retry with error context |
| **Security** | Import whitelist, block dangerous operations | Retry with allowed modules list |
| **Signature** | Verify `extract(path) -> dict` | Retry with signature template |
| **Sandbox** | Execute against sample paths | Retry or offer YAML fallback |

**Import Whitelist:**

Extractors may only import:
- `pathlib`, `os.path` - Path operations
- `re`, `string`, `fnmatch` - Pattern matching
- `datetime`, `time` - Date parsing
- `typing`, `collections`, `dataclasses`, `enum` - Type hints
- `json`, `math`, `uuid`, `base64`, `hashlib` - Data processing
- `urllib.parse` - URL parsing

**Blocked Operations:**

- File I/O (`open`, `io`, `shutil`)
- Network (`socket`, `urllib.request`, `http`)
- Subprocess (`subprocess`, `os.system`)
- Dynamic code (`exec`, `eval`, `compile`)

**Sandbox Properties:**

- Timeout: 5 seconds per path
- Isolated subprocess
- Restricted builtins

**Validation Display:**

Successful validation shows:
```
Validation: ✓ Passed (5/5 paths, avg 2.3ms)
```

Failed validation after retries offers:
- `[h]` Add hint for AI
- `[e]` Edit code manually
- `[y]` Try YAML fallback (simpler)
- `[Esc]` Cancel

See `specs/meta/sessions/ai_wizards/round_017/engineer.md` for full specification.
```

---

## 11. Trade-offs

**Pros:**
1. **Security by default** - No file/network access possible in extractors
2. **Fast feedback** - Syntax/security checks are instant, sandbox is <5s
3. **Retry-friendly** - Each stage provides specific context for LLM
4. **User confidence** - "Validated ✓" indicator builds trust

**Cons:**
1. **Import restrictions** - Some legitimate use cases blocked (e.g., `csv` module)
2. **Sandbox overhead** - Subprocess spawn adds ~50ms latency per test
3. **False negatives** - Sandbox tests only cover sample paths, not all edge cases

**Alternatives Considered:**

| Alternative | Rejected Because |
|-------------|------------------|
| Run in main process with `exec()` | Security risk, no timeout |
| Docker sandbox | Heavy dependency, slow startup |
| WebAssembly sandbox | Python WASM support immature |
| No validation | User safety, trust issues |
| WASM-based Python (Pyodide) | Too slow, incomplete stdlib |

---

## 12. New Gaps Introduced

None. This resolution is self-contained.

---

## 13. References

- `specs/ai_wizards.md` Section 3.1 (Pathfinder Wizard, Python extractor examples)
- `specs/ai_wizards.md` Section 9.4 (LLM Output Validation Pipeline)
- Python `ast` module documentation
- Python `multiprocessing` module documentation
- `specs/extraction.md` for YAML extraction rule format
